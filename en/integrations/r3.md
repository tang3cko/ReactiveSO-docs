---
layout: default
title: R3
parent: Integrations
nav_order: 1
---

# R3 Integration

{: .note }
> R3 Integration is available since v2.1.0. Requires [R3](https://github.com/Cysharp/R3) package to be installed.

---

## Purpose

This guide explains how to use Reactive SO with R3 (Reactive Extensions for Unity). R3 integration enables advanced reactive patterns like throttling, buffering, and combining multiple event streams.

---

## Prerequisites

Install the R3 package via NuGet for Unity or OpenUPM.

- Package ID: `com.cysharp.r3`
- GitHub: [https://github.com/Cysharp/R3](https://github.com/Cysharp/R3)

Once R3 is installed, extension methods become automatically available. No additional setup is required.

---

## EventChannel extensions

### AsObservable

Convert any EventChannel to an R3 Observable.

**Typed EventChannel**

```csharp
using Tang3cko.ReactiveSO;
using Tang3cko.ReactiveSO.R3;
using R3;
using UnityEngine;

public class DamageHandler : MonoBehaviour
{
    [SerializeField] private IntEventChannelSO onDamageReceived;

    private void Start()
    {
        // Convert event channel to Observable
        onDamageReceived.AsObservable()
            .Subscribe(damage => Debug.Log($"Received {damage} damage"))
            .AddTo(this);
    }
}
```

**VoidEventChannel**

```csharp
using Tang3cko.ReactiveSO;
using Tang3cko.ReactiveSO.R3;
using R3;
using UnityEngine;

public class GameOverHandler : MonoBehaviour
{
    [SerializeField] private VoidEventChannelSO onPlayerDeath;

    private void Start()
    {
        // VoidEventChannel emits Unit
        onPlayerDeath.AsObservable()
            .Subscribe(_ => ShowGameOverScreen())
            .AddTo(this);
    }

    private void ShowGameOverScreen() { /* ... */ }
}
```

---

## ReactiveEntitySet extensions

ReactiveEntitySet provides four observation methods for entity lifecycle events.

| Method | Emits | Description |
|--------|-------|-------------|
| `ObserveAdd()` | `int` (entity ID) | Emits when an entity is registered |
| `ObserveRemove()` | `int` (entity ID) | Emits when an entity is unregistered |
| `ObserveDataChanged()` | `int` (entity ID) | Emits when an entity's data is modified |
| `ObserveSetChanged()` | `Unit` | Emits on any change (add, remove, or data change) |

### Basic usage

```csharp
using Tang3cko.ReactiveSO;
using Tang3cko.ReactiveSO.R3;
using R3;
using UnityEngine;

public class EnemyTracker : MonoBehaviour
{
    [SerializeField] private EnemySet enemySet;

    private void Start()
    {
        // Track enemy additions
        enemySet.ObserveAdd()
            .Subscribe(id => Debug.Log($"Enemy {id} spawned"))
            .AddTo(this);

        // Track enemy removals
        enemySet.ObserveRemove()
            .Subscribe(id => Debug.Log($"Enemy {id} destroyed"))
            .AddTo(this);

        // Track data changes
        enemySet.ObserveDataChanged()
            .Subscribe(id => Debug.Log($"Enemy {id} data updated"))
            .AddTo(this);
    }
}
```

---

## Practical patterns

### Throttling high-frequency events

Prevent UI updates from firing too frequently.

```csharp
using Tang3cko.ReactiveSO;
using Tang3cko.ReactiveSO.R3;
using R3;
using System;
using UnityEngine;

public class HealthBar : MonoBehaviour
{
    [SerializeField] private IntEventChannelSO onHealthChanged;

    private void Start()
    {
        // Update UI at most once per 100ms
        onHealthChanged.AsObservable()
            .Throttle(TimeSpan.FromMilliseconds(100))
            .Subscribe(health => UpdateHealthBar(health))
            .AddTo(this);
    }

    private void UpdateHealthBar(int health) { /* ... */ }
}
```

### Combining multiple event streams

React to multiple events with a single subscription.

```csharp
using Tang3cko.ReactiveSO;
using Tang3cko.ReactiveSO.R3;
using R3;
using UnityEngine;

public class EnemyListUI : MonoBehaviour
{
    [SerializeField] private EnemySet enemySet;

    private void Start()
    {
        // Refresh list on any add or remove
        Observable.Merge(
            enemySet.ObserveAdd(),
            enemySet.ObserveRemove()
        )
        .Subscribe(_ => RefreshEnemyList())
        .AddTo(this);
    }

    private void RefreshEnemyList() { /* ... */ }
}
```

### Filtering events

Process only events that meet certain criteria.

```csharp
using Tang3cko.ReactiveSO;
using Tang3cko.ReactiveSO.R3;
using R3;
using UnityEngine;

public class CriticalDamageEffect : MonoBehaviour
{
    [SerializeField] private IntEventChannelSO onDamageReceived;

    private void Start()
    {
        // Only react to critical hits (damage > 50)
        onDamageReceived.AsObservable()
            .Where(damage => damage > 50)
            .Subscribe(damage => ShowCriticalHitEffect())
            .AddTo(this);
    }

    private void ShowCriticalHitEffect() { /* ... */ }
}
```

### Transforming event data

Transform event data before processing.

```csharp
using Tang3cko.ReactiveSO;
using Tang3cko.ReactiveSO.R3;
using R3;
using UnityEngine;

public class DamageLogger : MonoBehaviour
{
    [SerializeField] private IntEventChannelSO onDamageReceived;

    private void Start()
    {
        onDamageReceived.AsObservable()
            .Select(damage => $"Damage: {damage}")
            .Subscribe(message => Debug.Log(message))
            .AddTo(this);
    }
}
```

### Buffering events

Collect multiple events over time.

```csharp
using Tang3cko.ReactiveSO;
using Tang3cko.ReactiveSO.R3;
using R3;
using System;
using System.Linq;
using UnityEngine;

public class ComboCounter : MonoBehaviour
{
    [SerializeField] private IntEventChannelSO onDamageDealt;

    private void Start()
    {
        // Sum damage dealt in 2-second windows
        onDamageDealt.AsObservable()
            .Buffer(TimeSpan.FromSeconds(2))
            .Where(damages => damages.Count > 0)
            .Subscribe(damages =>
            {
                int totalDamage = damages.Sum();
                if (totalDamage > 100)
                {
                    ShowComboEffect(damages.Count, totalDamage);
                }
            })
            .AddTo(this);
    }

    private void ShowComboEffect(int hitCount, int totalDamage) { /* ... */ }
}
```

---

## Best practices

### Always dispose subscriptions

Use `AddTo` to automatically dispose subscriptions when the MonoBehaviour is destroyed.

```csharp
// Good: Subscription is disposed when GameObject is destroyed
onDamageReceived.AsObservable()
    .Subscribe(damage => HandleDamage(damage))
    .AddTo(this);

// Bad: Manual disposal required, easy to forget
var subscription = onDamageReceived.AsObservable()
    .Subscribe(damage => HandleDamage(damage));
// Must call subscription.Dispose() manually
```

### Use CompositeDisposable for multiple subscriptions

When you have many subscriptions, use `CompositeDisposable`.

```csharp
using Tang3cko.ReactiveSO;
using Tang3cko.ReactiveSO.R3;
using R3;
using UnityEngine;

public class GameUI : MonoBehaviour
{
    [SerializeField] private IntEventChannelSO onHealthChanged;
    [SerializeField] private IntEventChannelSO onScoreChanged;
    [SerializeField] private VoidEventChannelSO onGameOver;

    private CompositeDisposable disposables = new();

    private void Start()
    {
        onHealthChanged.AsObservable()
            .Subscribe(UpdateHealthUI)
            .AddTo(disposables);

        onScoreChanged.AsObservable()
            .Subscribe(UpdateScoreUI)
            .AddTo(disposables);

        onGameOver.AsObservable()
            .Subscribe(_ => ShowGameOverScreen())
            .AddTo(disposables);
    }

    private void OnDestroy()
    {
        disposables.Dispose();
    }

    private void UpdateHealthUI(int health) { /* ... */ }
    private void UpdateScoreUI(int score) { /* ... */ }
    private void ShowGameOverScreen() { /* ... */ }
}
```

### Avoid subscribing in hot paths

Subscriptions have overhead. Subscribe once during initialization, not every frame.

```csharp
// Good: Subscribe once in Start
private void Start()
{
    onDamageReceived.AsObservable()
        .Subscribe(HandleDamage)
        .AddTo(this);
}

// Bad: Creating new subscriptions frequently
private void Update()
{
    // Don't do this!
    onDamageReceived.AsObservable()
        .Take(1)
        .Subscribe(HandleDamage);
}
```

---

## When to use R3 integration

### Use R3 when

- You need time-based operations (Throttle, Delay, Buffer)
- You want to combine multiple event streams (Merge, CombineLatest)
- You need complex filtering or transformation logic
- Your team is already familiar with reactive programming

### Use standard events when

- Simple one-to-one event handling
- No complex processing required
- Minimal dependencies preferred

---

## References

- [Event Channels Guide]({{ '/en/guides/event-channels' | relative_url }})
- [Reactive Entity Sets Guide]({{ '/en/guides/reactive-entity-sets' | relative_url }})
- [R3 GitHub Repository](https://github.com/Cysharp/R3)
